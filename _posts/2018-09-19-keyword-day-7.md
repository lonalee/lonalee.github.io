---
title: Day 7
layout: post
---
> 전역 scope VS 지역 scope, this, 실행 컨텍스트


## 전역 scope VS 지역 scope

### 프로그램 내에서 SCOPE 란 식별자를 구별하기 위해서 유효 범위를 구별하는 규칙이라 말할 수 있다
<br>

* global scope

전역 객체 window 하위에서 선언되는 변수/함수들이 갖는 scope 입니다. 전역 scope는 함수 블럭 이외의 영역, 코드 가능한 모든 영역을 의미합니다. 이것은 코드 영역 어디에서나 참조가 가능함**_<u>(유효하다)</u>_**을 의미합니다. 전역 변수들은 함수 내부에서도 참조가 가능한 대상들이죠. <br>
이렇게 전역에 선언된 변수들은 var type의 특징?으로 인해서 중복선언 및 값의 재할당이 가능하기 때문에 의도치 않게 값이 변경될 가능성이 더욱 높아집니다. 어디서든 참조가 가능한 대상들이기 때문이지요.<br>
이를 보완하기 위해서 ES6에서는 let, const와 같은 다른 type으로 변수를 선언할 수 있게 합니다.

* local scope

자바스크립트는 기본적으로 함수 level scope를 지원합니다. 일반적인 C-family 언어들과는 다른 특징이지요. 일반적으로는 Block level scope를 지원하기 때문에 코드 블럭-{}-단위로 유효 범위가 정해집니다. <br>
JS에서는 함수 내에서만 (지역) scope가 정의됩니다. 함수 내에서 선언된 변수는 지역 변수로써, 그 안에서만 유효하고 전역에서는 참조할 수 없습니다.
그런데 **<u>내부함수의 경우는</u>** 외부함수의 것들을 참조 가능하고, 전역의 것들 또한 참조 가능합니다.<br>
*<u>이러한 특징은 closure와도 관련이 있습니다.</u>*

## this

### this는 실행 컨텍스트에 따라서 달라지는 행위의 대상?을 지시하는 매개체
<br>

*

## 실행 컨텍스트

### 실행 컨텐스트는 코드들의 실행 문맥, 실행 순서

 순서라고 해서 위에서 아래로만 이동하는게 아니라 문맥에 따라서 이동하게 되는 것입니다. 브라우저 창 생성 시 windows 객체가 생기고, 런타임 진입전에 변수들이 초기화 단계에 진입하고, 그래서 변수 객체(VO)에 그 변수의 식별자가 기록됩니다. 이러한 호이스팅으로 인해서 변수 선언 이전에 참조가 가능한 것입니다.
일단 window 객체가 생성되고 나서 전역 변수/함수들이 기록되고 나면 실행될 대상들이